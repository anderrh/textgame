<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Adventure Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #e0e0e0;
            overflow-x: hidden;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile browsers */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            margin: 0;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height */
            width: 100%;
            max-width: 600px;
            max-height: 800px;
            margin: 0 auto;
            position: relative;
            background: #1a1a1a;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            /* Properly account for iOS safe areas */
            padding-top: env(safe-area-inset-top, 0);
            padding-bottom: env(safe-area-inset-bottom, 0);
        }

        #passwordDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            border: 2px solid #4a9eff;
            border-radius: 10px;
            padding: 30px;
            z-index: 300;
            display: none;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            max-width: 90%;
            width: 400px;
        }

        #passwordDialog h2 {
            color: #4a9eff;
            margin-bottom: 20px;
            text-align: center;
        }

        #passwordInput {
            width: 100%;
            padding: 10px;
            background: #0a0a0a;
            border: 1px solid #666;
            border-radius: 5px;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            margin-bottom: 15px;
        }

        #passwordSubmit {
            width: 100%;
            padding: 10px;
            background: #4a9eff;
            border: none;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        #passwordSubmit:hover {
            background: #6abbff;
        }

        #passwordError {
            color: #ff6666;
            margin-top: 10px;
            text-align: center;
            display: none;
        }

        #imageContainer {
            width: 100%;
            height: 25vh;
            background: #000;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: height 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            /* Add extra padding at top to avoid URL bar */
            padding-top: env(safe-area-inset-top, 0);
        }

        #imageContainer.expanded {
            height: 50vh;
        }

        #imageContainer.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 200;
            background: #000;
        }

        #roomImage {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            touch-action: none;
        }

        #textArea {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #0a0a0a;
            border-top: 2px solid #333;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            transition: all 0.3s ease;
        }

        #imageContainer.expanded + #textArea {
            max-height: 30vh;
        }

        #chipsContainer {
            padding: 10px;
            padding-bottom: max(env(safe-area-inset-bottom, 20px), 20px);
            background: #1a1a1a;
            border-top: 2px solid #333;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 30vh;
            overflow-y: auto;
            position: relative;
            /* Ensure content is above iOS home indicator */
            z-index: 10;
        }

        .chip {
            padding: 10px 16px;
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 20px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            /* Prevent Android touch-to-search */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: manipulation;
        }

        .chip:hover, .chip:active {
            background: #3a3a3a;
            border-color: #666;
            transform: scale(0.98);
        }

        .chip.hard-to-find {
            opacity: 0.5;
            border-style: dashed;
        }

        .chip.inventory-btn {
            background: #1a4a5a;
            border-color: #4a9eff;
            font-weight: bold;
        }

        .chip.inventory-btn:hover {
            background: #2a5a6a;
        }

        #inventoryPanel {
            position: fixed;
            bottom: calc(20vh + env(safe-area-inset-bottom, 0));
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            max-height: 300px;
            background: rgba(30, 30, 30, 0.98);
            border: 2px solid #666;
            border-radius: 10px;
            padding: 15px;
            z-index: 150; /* Increased z-index */
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
        }

        #inventoryPanel.open {
            display: block;
        }

        #logOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99;
            display: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        #logOverlay.open {
            display: block;
        }

        #logPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            height: 80%;
            max-height: 600px;
            background: rgba(20, 20, 20, 0.98);
            border: 2px solid #666;
            border-radius: 10px;
            padding: 15px;
            padding-top: 55px; /* Less space needed for compact controls */
            z-index: 100;
            display: none;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.7);
            overflow: hidden;
        }

        #logPanel.open {
            display: flex;
            flex-direction: column;
        }

        /* Prevent body scroll when log is open */
        body.log-open {
            overflow: hidden;
        }

        #logContent {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            background: rgba(10, 10, 10, 0.8);
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            /* iOS smooth scrolling */
            -webkit-overflow-scrolling: touch;
            /* Ensure scrolling works properly */
            overscroll-behavior: contain;
            /* Prevent momentum scrolling from affecting parent */
            -webkit-transform: translateZ(0);
            /* Make it a textarea for iOS scrolling */
            border: none;
            outline: none;
            resize: none;
            font-family: 'Courier New', monospace;
            color: #e0e0e0;
            width: 100%;
            box-sizing: border-box;
        }
        #logClose {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 15px;
            background: #666;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        #logClose:hover {
            background: #888;
        }

        #logContent::-webkit-scrollbar {
            width: 8px;
        }

        #logContent::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        #logContent::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 4px;
        }

        #logContent::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        #inventoryPanel::-webkit-scrollbar {
            width: 8px;
        }

        #inventoryPanel::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        #inventoryPanel::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 4px;
        }

        #inventoryPanel::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        .inventory-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 5px;
            font-size: 12px;
        }

        .room-title {
            font-weight: bold;
            font-size: 18px;
            color: #4a9eff;
            margin-bottom: 10px;
            display: inline-block;
        }

        .room-title::first-line {
            text-decoration: underline;
            text-decoration-thickness: 2px;
            text-underline-offset: 3px;
        }

        .npc-count {
            color: #ffaa00;
            margin: 10px 0;
            display: inline-block;
        }

        .npc-count::after {
            content: '';
            display: block;
            width: 100%;
            height: 2px;
            background: #ffaa00;
            margin-top: 2px;
        }

        .destination-count {
            color: #00ff88;
            margin: 10px 0;
            display: inline-block;
        }

        .destination-count::after {
            content: '';
            display: block;
            width: 100%;
            height: 2px;
            background: #00ff88;
            margin-top: 2px;
        }

        .conditional-text {
            color: #ff9eff;
            font-style: italic;
            margin: 10px 0;
            padding: 10px;
            border-left: 3px solid #ff9eff;
        }

        .item-notice {
            color: #88ddff;
            font-style: italic;
            margin: 5px 0;
        }

        .speed-button {
            width: 30px;
            height: 30px;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .speed-button:hover {
            background: #555;
            border-color: #888;
        }

        .speed-button:active {
            background: #333;
            transform: scale(0.95);
        }

        #winMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            color: #0f0;
            padding: 40px;
            border: 3px solid #0f0;
            font-family: monospace;
            font-size: 14px;
            text-align: center;
            display: none;
            z-index: 200;
            white-space: pre;
        }

        /* Standalone app mode (when added to home screen) */
        @media (display-mode: standalone) {
            body {
                padding-top: 20px; /* Status bar height */
            }
            
            #gameContainer {
                padding-top: 20px;
            }
        }
        
        /* Fix for iOS minimal-ui mode */
        @supports (-webkit-touch-callout: none) {
            #gameContainer {
                min-height: -webkit-fill-available;
            }
        }
        /* Mobile optimizations */
        @media (max-width: 768px) {
            body {
                padding: 0;
                background: #1a1a1a;
                margin: 0;
            }
            
            #gameContainer {
                max-width: 100%;
                height: 100vh;
                /* Use smaller viewport height on mobile to account for UI */
                height: 100svh; 
                box-shadow: none;
                border-radius: 0;
                /* Reset max-height on mobile */
                max-height: none;
                /* Ensure safe areas are applied */
                padding-top: env(safe-area-inset-top, 0);
                padding-bottom: 0; /* Handled by chips container */
            }
            
            #imageContainer {
                /* Slightly reduce height to prevent clipping */
                height: 23vh;
                padding-top: 0; /* Remove double padding */
            }
            
            #imageContainer.expanded {
                height: 45vh; /* Slightly smaller when expanded */
            }
            
            #textArea {
                /* Ensure text area doesn't get too small */
                min-height: 20vh;
            }
            
            #chipsContainer {
                /* Better bottom padding for mobile */
                padding-bottom: max(env(safe-area-inset-bottom, 0) + 10px, 20px);
                max-height: 28vh; /* Slightly smaller to avoid bottom bar */
            }
            
            /* iOS standalone app mode (when added to home screen) */
            @media (display-mode: standalone) {
                #gameContainer {
                    padding-top: max(env(safe-area-inset-top, 20px), 20px);
                }
            }
        }
        
        /* iOS-specific fixes */
        @supports (-webkit-touch-callout: none) {
            /* iOS only */
            #gameContainer {
                /* Use the smaller viewport height unit */
                height: 100svh;
            }
            
            /* Prevent rubber band scrolling */
            body {
                position: fixed;
                width: 100%;
                overflow: hidden;
            }
            
            #textArea {
                /* Improve scrolling on iOS */
                -webkit-overflow-scrolling: touch;
            }
            
            #chipsContainer {
                /* Improve scrolling on iOS */
                -webkit-overflow-scrolling: touch;
            }
        }
        
        /* Android-specific fixes */
        @supports not (-webkit-touch-callout: none) {
            /* Non-iOS mobile browsers (primarily Android) */
            @media (max-width: 768px) and (pointer: coarse) {
                body {
                    position: relative;
                    overflow: hidden;
                    touch-action: none;
                }
                
                #gameContainer {
                    height: 100vh;
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                }
                
                /* Fix inventory panel positioning for Android */
                #inventoryPanel {
                    position: fixed !important;
                    bottom: 120px !important; /* Fixed position above chips */
                    left: 50% !important;
                    transform: translateX(-50%) !important;
                    z-index: 200 !important; /* Higher z-index for Android */
                    width: 85% !important;
                    max-height: 40vh !important;
                    background: rgba(30, 30, 30, 0.95) !important;
                }
                
                #inventoryPanel.open {
                    display: block !important;
                }
                
                #textArea {
                    /* Android scroll optimization */
                    overflow-scrolling: auto;
                    -webkit-overflow-scrolling: auto;
                }
                
                #chipsContainer {
                    /* Android scroll optimization */
                    overflow-scrolling: auto;
                    -webkit-overflow-scrolling: auto;
                    /* Add extra bottom padding for Android navigation bar */
                    padding-bottom: 80px !important;
                    /* Ensure scrolling works properly */
                    overflow-y: scroll !important;
                    /* Add some visual indication that there's more content */
                    padding-right: 5px;
                }
                
                /* Visual scroll indicator for Android */
                #chipsContainer::after {
                    content: '';
                    display: block;
                    height: 60px; /* Extra space at bottom for safety */
                    width: 100%;
                }
                
                /* Fix for Android Chrome URL bar */
                #imageContainer {
                    height: 22vh;
                }
                
                #imageContainer.expanded {
                    height: 43vh;
                }
                
                /* Ensure textarea works on Android */
                #logContent {
                    -webkit-user-select: text;
                    user-select: text;
                }
                
                /* Additional touch-to-search prevention for Android */
                .chip {
                    -webkit-touch-callout: none !important;
                    -webkit-user-select: none !important;
                    touch-action: manipulation !important;
                    /* Prevent long-press context menu */
                    -webkit-context-menu: none !important;
                }
                
                /* Ensure chips are always clickable on Android */
                .chip:active {
                    background: #3a3a3a !important;
                    border-color: #666 !important;
                }
                
                /* Ensure inventory button works on Android */
                .chip.inventory-btn {
                    position: relative !important;
                    z-index: 50 !important;
                }
            }
        }
        
        /* Viewport meta tag respect */
        @viewport {
            width: device-width;
            initial-scale: 1;
            maximum-scale: 1;
            user-scalable: no;
            viewport-fit: cover;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="imageContainer">
            <img id="roomImage" alt="Room">
        </div>
        <div id="textArea"></div>
        <div id="chipsContainer"></div>
        <div id="inventoryPanel"></div>
    </div>
    <div id="winMessage"></div>
    <div id="logOverlay" onclick="game.closeLog()"></div>
    <div id="logPanel">
        <div style="position: absolute; top: 15px; left: 15px; right: 15px; display: flex; align-items: center; justify-content: space-between;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <h3 style="color: #4a9eff; margin: 0;">üìú Log</h3>
                <span style="color: #666; font-size: 14px;">Speed:</span>
                <button class="speed-button" onclick="game.decreaseSpeed()" style="width: 24px; height: 24px;">-</button>
                <span id="speedIndicator" style="color: #4a9eff; min-width: 15px; text-align: center; font-size: 14px;">2</span>
                <button class="speed-button" onclick="game.increaseSpeed()" style="width: 24px; height: 24px;">+</button>
            </div>
            <button id="logClose" onclick="game.closeLog()" style="width: 30px; height: 30px; background: #666; border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;">√ó</button>
        </div>
        <textarea id="logContent" readonly></textarea>
    </div>
    
    <!-- Password Dialog -->
    <div id="passwordDialog">
        <h2>üîê Game Data Encrypted</h2>
        <input type="password" id="passwordInput" placeholder="Enter password" autocomplete="off">
        <button id="passwordSubmit" onclick="game.submitPassword()">Decrypt & Start Game</button>
        <div id="passwordError">Incorrect password. Please try again.</div>
    </div>
    
    <audio id="bgMusic" loop></audio>

    <script>
        // AES Encryption/Decryption utilities using Web Crypto API
        class CryptoHelper {
            static async deriveKey(password, salt) {
                const encoder = new TextEncoder();
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    'PBKDF2',
                    false,
                    ['deriveKey']
                );
                
                return crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    passwordKey,
                    { name: 'AES-CBC', length: 128 },
                    false,
                    ['decrypt', 'encrypt']
                );
            }

            static async decrypt(encryptedData, password) {
                try {
                    // Extract salt (first 16 bytes)
                    const salt = encryptedData.slice(0, 16);
                    // Extract IV (next 16 bytes)
                    const iv = encryptedData.slice(16, 32);
                    // Rest is the encrypted content
                    const encrypted = encryptedData.slice(32);
                    
                    const key = await this.deriveKey(password, salt);
                    
                    const decrypted = await crypto.subtle.decrypt(
                        {
                            name: 'AES-CBC',
                            iv: iv
                        },
                        key,
                        encrypted
                    );
                    
                    const decoder = new TextDecoder();
                    return decoder.decode(decrypted);
                } catch (error) {
                    console.error('Decryption error:', error);
                    return null;
                }
            }

            // Helper to check if data looks encrypted (starts with valid binary data)
            static isLikelyEncrypted(data) {
                // If it's ArrayBuffer or Uint8Array, it's likely encrypted
                if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
                    return true;
                }
                // If it's a string that starts with JSON, it's not encrypted
                if (typeof data === 'string' && (data.trim().startsWith('{') || data.trim().startsWith('['))) {
                    return false;
                }
                return false;
            }
        }

        class Game {
            constructor() {
                this.world = null;
                this.currentRoom = 0;
                this.inventory = [];
                this.textQueue = [];
                this.isTyping = false;
                this.currentAudio = null;
                this.fadeInterval = null;
                this.musicStarted = false;
                this.pendingMusic = null;
                this.sessionLog = []; // Track all text shown to user
                this.textSpeed = 2; // Characters per chunk (1-8)
                this.encryptedData = null; // Store encrypted data if found
                this.typingTimeout = null; // Store timeout reference for cancellation
                this.currentTypingText = ''; // Track current text being typed
                this.currentTextIndex = 0; // Track position in current text
                this.init();
            }

            async init() {
                // Single handler for all interaction types to prevent duplicates
                const startAudioOnInteraction = (e) => {
                    // Remove all listeners at once to prevent multiple triggers
                    ['click', 'touchstart', 'keydown'].forEach(eventType => {
                        document.removeEventListener(eventType, startAudioOnInteraction);
                    });
                    
                    if (!this.musicStarted) {
                        this.musicStarted = true;
                        // If we have pending music, play it
                        if (this.pendingMusic) {
                            const musicToPlay = this.pendingMusic;
                            this.pendingMusic = null; // Clear BEFORE playing
                            this.startNewMusic(musicToPlay);
                        }
                    }
                };
                
                // Add the same handler to multiple events
                ['click', 'touchstart', 'keydown'].forEach(eventType => {
                    document.addEventListener(eventType, startAudioOnInteraction);
                });

                // Initialize queue for music changes
                this.nextMusic = null;
                this.isFading = false;

                // Try to load world data
                await this.loadWorldData();
            }

            async loadWorldData() {
                try {
                    // Try the provided filename first
                    const response = await fetch('world_hando_expanded.json');
                    
                    // ALWAYS fetch as binary first to avoid corrupting encrypted data
                    const buffer = await response.arrayBuffer();
                    const bytes = new Uint8Array(buffer);
                    
                    // Check if it's JSON by looking at first byte
                    // JSON files start with { (123) or [ (91) or whitespace (32, 9, 10, 13)
                    const firstByte = bytes[0];
                    const textDecoder = new TextDecoder();
                    
                    if (firstByte === 123 || firstByte === 91 || firstByte === 32 || firstByte === 9 || firstByte === 10 || firstByte === 13) {
                        // Likely JSON, try to parse
                        try {
                            const text = textDecoder.decode(bytes);
                            const data = JSON.parse(text);
                            this.initializeGame(data);
                        } catch (e) {
                            // Not valid JSON, treat as encrypted
                            await this.handleEncryptedData(bytes);
                        }
                    } else {
                        // Binary data, treat as encrypted
                        await this.handleEncryptedData(bytes);
                    }
                } catch (error) {
                    // If that fails, try the original filename
                    try {
                        const response = await fetch('world_small.json');
                        const buffer = await response.arrayBuffer();
                        const bytes = new Uint8Array(buffer);
                        
                        const firstByte = bytes[0];
                        const textDecoder = new TextDecoder();
                        
                        if (firstByte === 123 || firstByte === 91 || firstByte === 32 || firstByte === 9 || firstByte === 10 || firstByte === 13) {
                            try {
                                const text = textDecoder.decode(bytes);
                                const data = JSON.parse(text);
                                this.initializeGame(data);
                            } catch (e) {
                                await this.handleEncryptedData(bytes);
                            }
                        } else {
                            await this.handleEncryptedData(bytes);
                        }
                    } catch (error2) {
                        this.addText("Error loading world data. Please ensure world_hando_expanded.json or world_small.json is available.");
                        console.error(error2);
                    }
                }
            }

            async handleEncryptedData(data) {
                // Store encrypted data and show password dialog
                this.encryptedData = data;
                const dialog = document.getElementById('passwordDialog');
                dialog.style.display = 'block';
                
                // Focus the password input
                const passwordInput = document.getElementById('passwordInput');
                passwordInput.focus();
                
                // Handle Enter key in password field
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.submitPassword();
                    }
                });
            }

            async submitPassword() {
                const passwordInput = document.getElementById('passwordInput');
                const password = passwordInput.value;
                
                if (!password) {
                    this.showPasswordError();
                    return;
                }
                
                // Try to decrypt
                const decrypted = await CryptoHelper.decrypt(this.encryptedData, password);
                
                if (decrypted) {
                    try {
                        const data = JSON.parse(decrypted);
                        // Hide dialog
                        document.getElementById('passwordDialog').style.display = 'none';
                        // Initialize game with decrypted data
                        this.initializeGame(data);
                    } catch (error) {
                        this.showPasswordError();
                    }
                } else {
                    this.showPasswordError();
                }
            }

            showPasswordError() {
                const errorDiv = document.getElementById('passwordError');
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 3000);
                
                // Clear and refocus password field
                const passwordInput = document.getElementById('passwordInput');
                passwordInput.value = '';
                passwordInput.focus();
            }

            initializeGame(worldData) {
                this.world = worldData;
                this.currentRoom = this.world.meta.spawn_points[Math.floor(Math.random() * this.world.meta.spawn_points.length)];
                this.inventory = [...this.world.meta.starter_inventory];
                
                this.setupEventListeners();
                
                // For initial room, clear the text area first
                const textArea = document.getElementById('textArea');
                textArea.innerHTML = '';
                
                this.describeRoom();
            }

            setupEventListeners() {
                // Image interaction handlers
                const imageContainer = document.getElementById('imageContainer');
                const roomImage = document.getElementById('roomImage');
                let pressTimer = null;
                let isLongPress = false;
                let lastTap = 0;
                let initialPinchDistance = null;
                let isPinching = false;
                
                // Helper function to get distance between two touch points
                const getTouchDistance = (e) => {
                    if (e.touches.length < 2) return null;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                };
                
                // Handle pinch gestures for mobile
                imageContainer?.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        isPinching = true;
                        initialPinchDistance = getTouchDistance(e);
                    } else if (e.touches.length === 1) {
                        // Start press timer for long press
                        startPress(e);
                    }
                }, { passive: false });
                
                imageContainer?.addEventListener('touchmove', (e) => {
                    if (isPinching && e.touches.length === 2) {
                        e.preventDefault();
                        const currentDistance = getTouchDistance(e);
                        if (initialPinchDistance && currentDistance) {
                            const distanceChange = currentDistance - initialPinchDistance;
                            // If pinch out (expand) by more than 30 pixels
                            if (distanceChange > 30) {
                                imageContainer.classList.add('expanded');
                                isPinching = false;
                                initialPinchDistance = null;
                            }
                            // If pinch in (contract) by more than 30 pixels
                            else if (distanceChange < -30) {
                                imageContainer.classList.remove('expanded');
                                isPinching = false;
                                initialPinchDistance = null;
                            }
                        }
                    }
                }, { passive: false });
                
                imageContainer?.addEventListener('touchend', (e) => {
                    if (isPinching) {
                        isPinching = false;
                        initialPinchDistance = null;
                    }
                    endPress(e);
                }, { passive: false });
                
                // Double tap to toggle size (works on both iOS and Android)
                imageContainer?.addEventListener('click', (e) => {
                    e.preventDefault();
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    
                    if (tapLength < 500 && tapLength > 0) {
                        // Double tap detected
                        imageContainer.classList.toggle('expanded');
                        // Adjust text area scroll after size change
                        setTimeout(() => {
                            const textArea = document.getElementById('textArea');
                            if (textArea) textArea.scrollTop = textArea.scrollHeight;
                        }, 350);
                    }
                    lastTap = currentTime;
                });
                
                // Press and hold for fullscreen
                const startPress = (e) => {
                    if (isPinching) return; // Don't start long press if pinching
                    e.preventDefault();
                    isLongPress = false;
                    pressTimer = setTimeout(() => {
                        isLongPress = true;
                        imageContainer?.classList.add('fullscreen');
                    }, 500); // 500ms hold for fullscreen
                };
                
                const endPress = (e) => {
                    e.preventDefault();
                    if (pressTimer) clearTimeout(pressTimer);
                    if (isLongPress) {
                        imageContainer?.classList.remove('fullscreen');
                        isLongPress = false;
                    }
                };
                
                // Mouse events for desktop (keep existing functionality)
                imageContainer?.addEventListener('mousedown', startPress);
                imageContainer?.addEventListener('mouseup', endPress);
                imageContainer?.addEventListener('mouseleave', endPress);
                
                // Prevent context menu on long press
                imageContainer?.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Android-specific touch handling for better scrolling
                if (navigator.userAgent.toLowerCase().indexOf('android') > -1) {
                    const scrollableElements = [
                        document.getElementById('textArea'),
                        document.getElementById('chipsContainer'),
                        document.getElementById('logContent')
                    ];
                    
                    scrollableElements.forEach(element => {
                        if (element) {
                            // Ensure smooth scrolling on Android
                            element.style.overflowY = 'auto';
                            element.style.WebkitOverflowScrolling = 'auto';
                        }
                    });
                    
                    // Prevent touch-to-search on chips
                    const chipsContainer = document.getElementById('chipsContainer');
                    if (chipsContainer) {
                        // Prevent default touch behavior that triggers search
                        chipsContainer.addEventListener('touchstart', (e) => {
                            if (e.target.classList.contains('chip')) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        }, { passive: false });
                        
                        // Convert touch to click for chips
                        chipsContainer.addEventListener('touchend', (e) => {
                            if (e.target.classList.contains('chip')) {
                                e.preventDefault();
                                e.stopPropagation();
                                // Trigger the onclick directly
                                e.target.click();
                            }
                        }, { passive: false });
                        
                        // Prevent context menu on long press
                        chipsContainer.addEventListener('contextmenu', (e) => {
                            if (e.target.classList.contains('chip')) {
                                e.preventDefault();
                                return false;
                            }
                        });
                    }
                    
                    // Add visual feedback for Android bottom padding
                    const updateChipsVisibility = () => {
                        const chips = chipsContainer;
                        if (chips && chips.scrollHeight > chips.clientHeight) {
                            chips.style.borderBottom = '2px dashed #666';
                        }
                    };
                    
                    // Check on load and when chips update
                    setTimeout(updateChipsVisibility, 100);
                    
                    // Override updateChips to add Android-specific handling
                    const originalUpdateChips = this.updateChips.bind(this);
                    this.updateChips = function() {
                        originalUpdateChips();
                        setTimeout(updateChipsVisibility, 10);
                    };
                }
            }

            d20() {
                return Math.floor(Math.random() * 20) + 1;
            }

            difficultyCheck(diff, advantage, disadvantage) {
                const firstRoll = this.d20();
                const secondRoll = this.d20();
                const goal = diff + 10;

                if (advantage === disadvantage) {
                    return firstRoll >= goal;
                }
                if (advantage) {
                    return Math.max(firstRoll, secondRoll) >= goal;
                }
                if (disadvantage) {
                    return Math.min(firstRoll, secondRoll) >= goal;
                }
                return false;
            }

            getRoomById(roomId) {
                if (!this.world) return null;
                return this.world.world.find(r => r.id === roomId) || null;
            }

            hasRequires(requires) {
                for (const req of requires) {
                    const found = this.inventory.some(item => 
                        item.name === req || item.type === req
                    );
                    if (!found) return false;
                }
                return true;
            }

            findTypes() {
                return new Set(this.inventory.map(item => item.type));
            }

            async playMusic(filename) {
                // Store as pending if music hasn't started
                if (!this.musicStarted) {
                    this.pendingMusic = filename;
                    return;
                }
                
                const audio = document.getElementById('bgMusic');
                
                // If we're already playing this exact file, do nothing
                if (audio && audio.src && audio.src.includes(filename) && !audio.paused && audio.volume > 0) {
                    return; // Already playing this track at normal volume
                }
                
                // Store the next music to play
                this.nextMusic = filename;
                
                // If we're already fading, the fade will pick up the new nextMusic
                if (this.isFading) {
                    return;
                }
                
                // Clear any existing fade intervals (cleanup)
                if (this.fadeInterval) {
                    clearInterval(this.fadeInterval);
                    this.fadeInterval = null;
                }
                
                // Start fade out if something is playing
                if (audio && !audio.paused && audio.volume > 0) {
                    this.isFading = true;
                    let fadeVolume = audio.volume;
                    
                    this.fadeInterval = setInterval(() => {
                        fadeVolume -= 0.1;
                        if (fadeVolume <= 0) {
                            audio.volume = 0;
                            audio.pause();
                            clearInterval(this.fadeInterval);
                            this.fadeInterval = null;
                            this.isFading = false;
                            
                            // Play the most recently requested music
                            if (this.nextMusic) {
                                const musicToPlay = this.nextMusic;
                                this.nextMusic = null;
                                this.startNewMusic(musicToPlay);
                            }
                        } else {
                            audio.volume = fadeVolume;
                        }
                    }, 50);
                } else {
                    // Nothing playing, start immediately
                    this.nextMusic = null;
                    this.startNewMusic(filename);
                }
            }

            startNewMusic(filename) {
                const audio = document.getElementById('bgMusic');
                
                // Don't restart if it's the same file already playing
                if (audio.src && audio.src.includes(filename) && !audio.paused) {
                    // Just make sure it's at full volume
                    audio.volume = 1;
                    return;
                }
                
                // Clear any lingering intervals
                if (this.fadeInterval) {
                    clearInterval(this.fadeInterval);
                    this.fadeInterval = null;
                }
                
                audio.src = filename;
                audio.volume = 0;
                
                // Try to play, and if successful, fade in
                audio.play().then(() => {
                    let fadeVolume = 0;
                    this.fadeInterval = setInterval(() => {
                        fadeVolume += 0.1;
                        if (fadeVolume >= 1) {
                            audio.volume = 1;
                            clearInterval(this.fadeInterval);
                            this.fadeInterval = null;
                        } else {
                            audio.volume = fadeVolume;
                        }
                    }, 50);
                }).catch((err) => {
                    // Audio couldn't play (likely autoplay policy)
                    console.log('Audio play failed:', err);
                });
                
                this.currentAudio = audio;
            }

            async loadImage(filename) {
                const img = document.getElementById('roomImage');
                
                // Return a promise but DON'T await it in describeRoom
                return new Promise((resolve) => {
                    const preloader = new Image();
                    preloader.onload = () => {
                        img.src = filename;
                        resolve();
                    };
                    preloader.onerror = () => {
                        img.src = ''; 
                        resolve();
                    };
                    preloader.src = filename;
                });
            }

            getConditionalDescriptions(room) {
                if (!room.conditional_descriptions) return [];
                
                const activeDescriptions = [];
                for (const condDesc of room.conditional_descriptions) {
                    if (this.hasRequires(condDesc.requirements)) {
                        activeDescriptions.push(condDesc.text);
                    }
                }
                return activeDescriptions;
            }

            async describeRoom() {
                const room = this.getRoomById(this.currentRoom);
                if (!room) return;

                // Start loading image but DON'T wait for it
                const imageName = `images/${this.currentRoom}a.png`;
                const imagePromise = this.loadImage(imageName);  // Note: no await here!
                
                // Start music setup immediately
                const musicName = `audio/${this.currentRoom}a.m4a`;
                this.playMusic(musicName);

                // Build and show description text IMMEDIATELY
                let text = '';
                if (!this.musicStarted) {
                    text += '[Click anywhere to start audio]\n\n';
                }
                
                // Format room title with full first word underlined
                const roomName = room.name;
                const firstSpaceIndex = roomName.indexOf(' ');
                const firstWord = firstSpaceIndex > -1 ? roomName.substring(0, firstSpaceIndex) : roomName;
                const restOfName = firstSpaceIndex > -1 ? roomName.substring(firstSpaceIndex) : '';
                
                text += `<span class="room-title"><span style="text-decoration: underline; text-decoration-thickness: 2px; text-underline-offset: 3px;">${firstWord}</span>${restOfName}</span>\n`;
                text += '-----------------\n';
                text += `${room.description}\n\n`;

                // Add conditional descriptions
                const conditionalTexts = this.getConditionalDescriptions(room);
                for (const condText of conditionalTexts) {
                    text += `<span class="conditional-text">${condText}</span>\n\n`;
                }

                // NPCs with styled count
                if (room.npcs && room.npcs.length > 0) {
                    const npcText = `There ${room.npcs.length === 1 ? 'is 1 person' : `are ${room.npcs.length} people`} in the room:`;
                    const npcFirstSpace = npcText.indexOf(' ');
                    const npcFirstWord = npcFirstSpace > -1 ? npcText.substring(0, npcFirstSpace) : npcText;
                    const npcRest = npcFirstSpace > -1 ? npcText.substring(npcFirstSpace) : '';
                    
                    text += `<span class="npc-count"><span style="border-bottom: 2px solid #ffaa00; padding-bottom: 2px;">${npcFirstWord}</span>${npcRest}</span>\n`;
                    for (const npc of room.npcs) {
                        text += ` ‚Ä¢ ${npc.name} - ${npc.short_desc || npc.description || 'Person'}\n`;
                    }
                    text += '\n';
                }

                // Exits with styled count
                const exitCount = Object.keys(room.exits).length;
                const exitText = `There ${exitCount === 1 ? 'is 1 destination' : `are ${exitCount} destinations`}:`;
                const exitFirstSpace = exitText.indexOf(' ');
                const exitFirstWord = exitFirstSpace > -1 ? exitText.substring(0, exitFirstSpace) : exitText;
                const exitRest = exitFirstSpace > -1 ? exitText.substring(exitFirstSpace) : '';
                
                text += `<span class="destination-count"><span style="border-bottom: 2px solid #00ff88; padding-bottom: 2px;">${exitFirstWord}</span>${exitRest}</span>\n`;
                for (const [direction, exits] of Object.entries(room.exits)) {
                    text += ` ‚Ä¢ ${direction}`;
                    for (const exit of exits) {
                        text += ` - ${exit.short_desc}`;
                    }
                    text += '\n';
                }

                // Start showing text immediately
                this.addText(text);
                this.updateChips();
                
                // Optional: You can still wait for the image in the background if you want
                // to do something when it finishes (like log it), but it won't block anything
                imagePromise.then(() => {
                    console.log('Image loaded for room:', this.currentRoom);
                }).catch(err => {
                    console.log('Image failed to load:', err);
                });
            }

            // Instantly complete any typing and flush all queued text
            flushText() {
                // Cancel any current typing timeout
                if (this.typingTimeout) {
                    clearTimeout(this.typingTimeout);
                    this.typingTimeout = null;
                }
                
                // If currently typing, finish the current text instantly
                if (this.isTyping && this.currentTypingText) {
                    const textArea = document.getElementById('textArea');
                    // Add any remaining part of current text
                    const remainingText = this.currentTypingText.substring(this.currentTextIndex || 0);
                    textArea.innerHTML += remainingText;
                }
                
                // Flush all queued text instantly
                while (this.textQueue.length > 0) {
                    const text = this.textQueue.shift();
                    const textArea = document.getElementById('textArea');
                    textArea.innerHTML += text;
                }
                
                // Reset typing state
                this.isTyping = false;
                this.currentTypingText = '';
                this.currentTextIndex = 0;
                
                // Scroll to bottom
                const textArea = document.getElementById('textArea');
                textArea.scrollTop = textArea.scrollHeight;
            }

            addText(text) {
                this.textQueue.push(text);
                // Add to session log (strip HTML tags for cleaner log)
                const cleanText = text.replace(/<[^>]*>/g, '');
                this.sessionLog.push(cleanText);
                if (!this.isTyping) {
                    this.typeText();
                }
            }

            async typeText() {
                if (this.textQueue.length === 0) {
                    this.isTyping = false;
                    this.currentTypingText = '';
                    this.currentTextIndex = 0;
                    return;
                }

                this.isTyping = true;
                const text = this.textQueue.shift();
                this.currentTypingText = text; // Track what we're typing
                const textArea = document.getElementById('textArea');
                
                // Type out character by character
                let index = 0;
                this.currentTextIndex = 0; // Track where we are in case we need to flush
                const typingSpeed = 10; // Delay between character chunks
                const charsPerChunk = this.textSpeed; // Use the adjustable speed
                
                const typeChar = () => {
                    if (index < text.length) {
                        let chunkSize = 0;
                        let chunkText = '';
                        
                        // Process up to charsPerChunk characters
                        while (chunkSize < charsPerChunk && index < text.length) {
                            // Handle HTML tags
                            if (text[index] === '<') {
                                const closeTag = text.indexOf('>', index);
                                if (closeTag !== -1) {
                                    chunkText += text.substring(index, closeTag + 1);
                                    index = closeTag + 1;
                                    // Don't count HTML tags in chunk size
                                } else {
                                    chunkText += text[index];
                                    index++;
                                    chunkSize++;
                                }
                            } else {
                                chunkText += text[index];
                                index++;
                                chunkSize++;
                            }
                        }
                        
                        this.currentTextIndex = index; // Update position
                        textArea.innerHTML += chunkText;
                        
                        // Always scroll to bottom to keep new text visible
                        textArea.scrollTop = textArea.scrollHeight;
                        
                        this.typingTimeout = setTimeout(typeChar, typingSpeed);
                    } else {
                        // Final scroll to ensure everything is visible
                        textArea.scrollTop = textArea.scrollHeight;
                        this.isTyping = false;
                        this.currentTypingText = '';
                        this.currentTextIndex = 0;
                        this.typingTimeout = null;
                        this.typeText();
                    }
                };
                
                typeChar();
            }

            go(direction) {
                const room = this.getRoomById(this.currentRoom);
                if (!room) return;

                if (!(direction in room.exits)) {
                    return;
                }

                const exits = room.exits[direction];
                for (let i = exits.length - 1; i >= 0; i--) {
                    const exit = exits[i];
                    if (this.hasRequires(exit.requires)) {
                        this.currentRoom = exit.to;
                        
                        // Flush any pending text instantly before clearing
                        this.flushText();
                        
                        // Clear text area BEFORE adding traversal text
                        const textArea = document.getElementById('textArea');
                        textArea.innerHTML = '';
                        
                        // Add traversal text
                        this.addText(exit.traversal + '\n\n');
                        
                        // Small delay before room description for readability
                        setTimeout(() => this.describeRoom(), 100);
                        return;
                    }
                }

                // If we get here, we're blocked
                this.addText(exits[exits.length - 1].blocked_text + '\n');
            }

            getItem(itemName) {
                const room = this.getRoomById(this.currentRoom);
                if (!room) return;

                const itemIndex = room.items.findIndex(item => 
                    item.name.toUpperCase() === itemName.toUpperCase()
                );

                if (itemIndex !== -1) {
                    const item = room.items[itemIndex];
                    this.inventory.push(item);
                    room.items.splice(itemIndex, 1);
                    
                    // Print both the standard message and the item's notice
                    let message = `You take the ${item.name}\n`;
                    if (item.notice) {
                        message += `<span class="item-notice">${item.notice}</span>\n`;
                    }
                    this.addText(message);
                    
                    // Check if this unlocked any conditional text
                    const conditionalTexts = this.getConditionalDescriptions(room);
                    for (const condText of conditionalTexts) {
                        // Check if this is a newly revealed text
                        if (!this.revealedTexts) this.revealedTexts = new Set();
                        const textKey = `${this.currentRoom}_${condText}`;
                        if (!this.revealedTexts.has(textKey)) {
                            this.revealedTexts.add(textKey);
                            this.addText(`\n<span class="conditional-text">New insight: ${condText}</span>\n`);
                        }
                    }
                    
                    this.updateChips();
                }
            }

            increaseSpeed() {
                if (this.textSpeed < 8) {
                    this.textSpeed++;
                    this.updateSpeedIndicator();
                }
            }

            decreaseSpeed() {
                if (this.textSpeed > 1) {
                    this.textSpeed--;
                    this.updateSpeedIndicator();
                }
            }

            updateSpeedIndicator() {
                const indicator = document.getElementById('speedIndicator');
                if (indicator) {
                    indicator.textContent = this.textSpeed.toString();
                }
            }

            showLog() {
                const logPanel = document.getElementById('logPanel');
                const logContent = document.getElementById('logContent');
                const logOverlay = document.getElementById('logOverlay');
                
                if (logPanel && logContent) {
                    // Show overlay
                    if (logOverlay) {
                        logOverlay.classList.add('open');
                    }
                    
                    // Simple body overflow prevention
                    document.body.classList.add('log-open');
                    
                    // Join all session log entries with some separation
                    logContent.value = this.sessionLog.join('\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n');
                    logPanel.classList.add('open');
                    
                    // Update speed indicator
                    this.updateSpeedIndicator();
                    
                    // Scroll to bottom to show most recent
                    setTimeout(() => {
                        logContent.scrollTop = logContent.scrollHeight;
                        // Prevent keyboard from appearing on iOS
                        logContent.blur();
                    }, 10);
                }
            }

            closeLog() {
                const logPanel = document.getElementById('logPanel');
                const logOverlay = document.getElementById('logOverlay');
                
                if (logPanel) {
                    logPanel.classList.remove('open');
                }
                
                if (logOverlay) {
                    logOverlay.classList.remove('open');
                }
                
                // Restore body scrolling
                document.body.classList.remove('log-open');
            }

            look() {
                // Deprecated - keeping for compatibility but now shows log
                this.showLog();
            }

            talk(npcName) {
                const room = this.getRoomById(this.currentRoom);
                if (!room || !room.npcs) return;

                const npc = room.npcs.find(n => n.name.toUpperCase() === npcName.toUpperCase());
                if (npc) {
                    const dialogue = Array.isArray(npc.dialogue) 
                        ? npc.dialogue[Math.floor(Math.random() * npc.dialogue.length)]
                        : npc.dialogue;
                    this.addText(`${npc.name} says: ${dialogue}\n`);
                }
            }

            craftInputs(itemName) {
                if (!this.world || !this.world.meta.crafting) return [];
                const recipe = this.world.meta.crafting.interactions.find(r => 
                    r.output.toUpperCase() === itemName.toUpperCase()
                );
                return recipe ? recipe.input : [];
            }

            craftable(itemName) {
                const inputs = this.craftInputs(itemName);
                if (inputs.length === 0) return false;
                
                return inputs.every(input => 
                    this.inventory.some(item => item.name === input)
                );
            }

            craft(itemName) {
                if (!this.world || !this.world.meta.crafting) return;
                
                if (this.craftable(itemName)) {
                    // Remove ingredients
                    const inputs = this.craftInputs(itemName);
                    for (const input of inputs) {
                        const index = this.inventory.findIndex(item => item.name === input);
                        if (index !== -1) {
                            this.inventory.splice(index, 1);
                        }
                    }

                    // Add crafted item
                    const recipe = this.world.meta.crafting.interactions.find(r => 
                        r.output.toUpperCase() === itemName.toUpperCase()
                    );
                    if (recipe) {
                        const craftedItem = {
                            name: recipe.output,
                            type: recipe.type,
                            notice: recipe.notice,
                            notes: recipe.notes
                        };
                        this.inventory.push(craftedItem);
                        
                        // Show crafting message and the item's notice
                        let message = `You craft the ${itemName}\n`;
                        if (craftedItem.notice) {
                            message += `<span class="item-notice">${craftedItem.notice}</span>\n`;
                        }
                        this.addText(message);
                        
                        // Check if this crafting unlocked any conditional text
                        const room = this.getRoomById(this.currentRoom);
                        const conditionalTexts = this.getConditionalDescriptions(room);
                        for (const condText of conditionalTexts) {
                            if (!this.revealedTexts) this.revealedTexts = new Set();
                            const textKey = `${this.currentRoom}_${condText}`;
                            if (!this.revealedTexts.has(textKey)) {
                                this.revealedTexts.add(textKey);
                                this.addText(`\n<span class="conditional-text">...: ${condText}</span>\n`);
                            }
                        }
                    }
                }
                
                this.updateChips();
                this.updateInventoryDisplay();
            }

            give(itemName, personName) {
                const room = this.getRoomById(this.currentRoom);
                if (!room || !room.trades) return;

                // Find matching trade
                for (const trade of room.trades) {
                    if (trade.name.toUpperCase() === personName.toUpperCase()) {
                        // Check if we have all required items
                        if (trade.input.includes(itemName) && 
                            trade.input.every(input => this.inventory.some(item => item.name === input))) {
                            
                            // Remove traded items
                            for (const input of trade.input) {
                                const index = this.inventory.findIndex(item => item.name === input);
                                if (index !== -1) {
                                    this.inventory.splice(index, 1);
                                }
                            }

                            // Add received items with their notices
                            for (const output of trade.output) {
                                let message = '';
                                if (output.notice) {
                                    message = `<span class="item-notice">${output.notice}</span>\n`;
                                }
                                this.addText(message);
                                this.inventory.push(output);
                            }
                            
                            this.updateChips();
                            this.updateInventoryDisplay();
                            return;
                        } else {
                            this.addText(trade.failure + '\n');
                            return;
                        }
                    }
                }
            }

            save() {
                if (!this.world) return;
                
                const saveData = {
                    ...this.world,
                    meta: {
                        ...this.world.meta,
                        spawn_points: [this.currentRoom],
                        starter_inventory: this.inventory
                    }
                };
                
                const blob = new Blob([JSON.stringify(saveData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'save.json';
                a.click();
                URL.revokeObjectURL(url);
                
                this.addText("Game saved!\n");
            }

            async loadSave() {
                // Create invisible file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                
                fileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        try {
                            const text = await file.text();
                            const saveData = JSON.parse(text);
                            
                            // Load the saved game state
                            this.world = saveData;
                            this.currentRoom = saveData.meta.spawn_points[0];
                            this.inventory = [...saveData.meta.starter_inventory];
                            
                            // Flush any pending text before clearing
                            this.flushText();
                            
                            // Clear and redraw everything
                            const textArea = document.getElementById('textArea');
                            textArea.innerHTML = '';
                            
                            this.addText("Save file loaded successfully!\n\n");
                            await this.describeRoom();
                        } catch (error) {
                            this.addText("Error loading save file. Please check the file and try again.\n");
                            console.error(error);
                        }
                    } else {
                        // No file selected, do a normal restart
                        if (confirm('No save file selected. Start a new game?')) {
                            location.reload();
                        }
                    }
                };
                
                // Trigger file selection dialog
                fileInput.click();
            }

            restart() {
                location.reload();
            }

            checkWin() {
                if (!this.world || !this.world.meta.parallel_portal) return false;
                const room = this.getRoomById(this.currentRoom);
                return room?.name === this.world.meta.parallel_portal.portal_room;
            }

            showWinMessage() {
                const winMessage = document.getElementById('winMessage');
                winMessage.innerHTML = `
  ____                            _         _       _   _                   
 / ___|___  _ __   __ _ _ __ __ _| |_ _   _| | __ _| |_(_) ___  _ __  ___   
| |   / _ \\| '_ \\ / _\` | '__/ _\` | __| | | | |/ _\` | __| |/ _ \\| '_ \\/ __|  
| |__| (_) | | | | (_| | | | (_| | |_| |_| | | (_| | |_| | (_) | | | \\__ \\_ 
 \\____\\___/|_| |_|\\__, |_|  \\__,_|\\__|\\__,_|_|\\__,_|\\__|_|\\___/|_| |_|___( )
                  |___/                                                  |/ 
__   __           __        ___         _   _   _ 
\\ \\ / /__  _   _  \\ \\      / (_)_ __   | | | | | |
 \\ V / _ \\| | | |  \\ \\ /\\ / /| | '_ \\  | | | | | |
  | | (_) | |_| |   \\ V  V / | | | | | |_| |_| |_|
  |_|\\___/ \\__,_|    \\_/\\_/  |_|_| |_| (_) (_) (_)`;
                winMessage.style.display = 'block';
            }

            updateInventoryDisplay() {
                const panel = document.getElementById('inventoryPanel');
                if (!panel || !panel.classList.contains('open')) return;

                let html = '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                html += '<h3 style="color: #4a9eff; margin: 0;">üì¶ Inventory</h3>';
                // Use direct window.game reference to ensure it works
                html += '<button onclick="window.game.closeInventory(); return false;" style="width: 30px; height: 30px; background: #666; border: none; border-radius: 5px; color: white; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;">√ó</button>';
                html += '</div>';
                
                const sortedInventory = [...this.inventory].sort((a, b) => 
                    a.name.localeCompare(b.name)
                );
                
                for (const item of sortedInventory) {
                    const notes = item.notes || 'Normal item';
                    html += `<div class="inventory-item">${item.name} - ${notes}</div>`;
                }
                
                if (sortedInventory.length === 0) {
                    html += '<div class="inventory-item">Empty</div>';
                }
                
                panel.innerHTML = html;
            }

            toggleInventory() {
                const invPanel = document.getElementById('inventoryPanel');
                if (invPanel) {
                    invPanel.classList.toggle('open');
                    if (invPanel.classList.contains('open')) {
                        this.updateInventoryDisplay();
                    }
                }
            }

            closeInventory() {
                const invPanel = document.getElementById('inventoryPanel');
                if (invPanel) {
                    invPanel.classList.remove('open');
                }
            }

            updateChips() {
                const container = document.getElementById('chipsContainer');
                
                // Save inventory panel state before updating
                const invPanel = document.getElementById('inventoryPanel');
                const wasOpen = invPanel?.classList.contains('open');
                
                const chips = [];
                
                // Always show inventory button first
                chips.push(`<div class="chip inventory-btn" onclick="game.toggleInventory()">üì¶ Inventory</div>`);
                
                const room = this.getRoomById(this.currentRoom);
                if (!room) return;

                // Check for win condition
                if (this.checkWin()) {
                    this.showWinMessage();
                    container.innerHTML = chips.join('');
                    // Restore inventory state
                    if (wasOpen && invPanel) {
                        invPanel.classList.add('open');
                    }
                    return;
                }

                // Navigation chips
                for (const direction of Object.keys(room.exits)) {
                    chips.push(`<div class="chip" onclick="game.go('${direction}')">Go ${direction}</div>`);
                }

                // Item chips (both visible and hard to find)
                if (room.items) {
                    for (const item of room.items) {
                        const myTypes = this.findTypes();
                        let difficulty = 'normal';
                        
                        if (!item.found && item.find_difficulty && item.find_difficulty > 0) {
                            let adv = false;
                            let dis = false;
                            
                            if (item.check) {
                                const advTypes = new Set(item.check.advantage_if_types || []);
                                const disTypes = new Set(item.check.disadvantage_if_missing_types || []);
                                
                                if (advTypes.size > 0) {
                                    adv = [...advTypes].every(t => myTypes.has(t));
                                }
                                
                                if (disTypes.size > 0 && ![...disTypes].some(t => myTypes.has(t))) {
                                    dis = true;
                                }
                            }
                            
                            // Make it translucent if hard to find
                            if (item.find_difficulty > 0 || dis) {
                                difficulty = 'hard-to-find';
                            }
                        }
                        
                        const itemNameEscaped = item.name.replace(/'/g, "\\'");
                        chips.push(`<div class="chip ${difficulty === 'hard-to-find' ? 'hard-to-find' : ''}" onclick="game.getItem('${itemNameEscaped}')">Get ${item.name}</div>`);
                    }
                }

                // Look chip
                chips.push(`<div class="chip" onclick="game.showLog()">Log</div>`);

                // Talk chips
                if (room.npcs) {
                    for (const npc of room.npcs) {
                        const npcNameEscaped = npc.name.replace(/'/g, "\\'");
                        chips.push(`<div class="chip" onclick="game.talk('${npcNameEscaped}')">Talk ${npc.name}</div>`);
                    }
                }

                // Give chips (for trades)
                if (room.trades) {
                    const tradeableItems = new Set();
                    for (const trade of room.trades) {
                        for (const input of trade.input) {
                            if (this.inventory.some(item => item.name === input)) {
                                tradeableItems.add(`${input} to ${trade.name}`);
                            }
                        }
                    }
                    
                    for (const trade of tradeableItems) {
                        const [item, person] = trade.split(' to ');
                        const itemEscaped = item.replace(/'/g, "\\'");
                        const personEscaped = person.replace(/'/g, "\\'");
                        chips.push(`<div class="chip" onclick="game.give('${itemEscaped}', '${personEscaped}')">Give ${trade}</div>`);
                    }
                }

                // Craft chips
                if (this.world && this.world.meta.crafting) {
                    for (const recipe of this.world.meta.crafting.interactions) {
                        if (this.craftable(recipe.output)) {
                            const outputEscaped = recipe.output.replace(/'/g, "\\'");
                            chips.push(`<div class="chip" onclick="game.craft('${outputEscaped}')">Craft ${recipe.output}</div>`);
                        }
                    }
                }

                // System chips
                chips.push(`<div class="chip" onclick="game.save()">Save</div>`);
                chips.push(`<div class="chip" onclick="game.loadSave()">Load</div>`);

                container.innerHTML = chips.join('');
                
                // Android-specific: Re-attach touch prevention after updating chips
                if (navigator.userAgent.toLowerCase().indexOf('android') > -1) {
                    const allChips = container.querySelectorAll('.chip');
                    allChips.forEach(chip => {
                        // Disable text selection completely
                        chip.style.webkitUserSelect = 'none';
                        chip.style.userSelect = 'none';
                        chip.style.webkitTouchCallout = 'none';
                        
                        // Don't override the inventory button's existing onclick
                        if (!chip.classList.contains('inventory-btn')) {
                            // Add touch event handlers for other chips
                            chip.addEventListener('touchstart', (e) => {
                                e.preventDefault();
                                chip.style.background = '#3a3a3a';
                            }, { passive: false });
                            
                            chip.addEventListener('touchend', (e) => {
                                e.preventDefault();
                                chip.style.background = '';
                                // Execute the onclick handler
                                const onclickAttr = chip.getAttribute('onclick');
                                if (onclickAttr) {
                                    try {
                                        eval(onclickAttr);
                                    } catch(err) {
                                        console.error('Chip action error:', err);
                                    }
                                }
                            }, { passive: false });
                        }
                    });
                }
                
                // Restore inventory panel state if it was open
                if (wasOpen && invPanel) {
                    invPanel.classList.add('open');
                    this.updateInventoryDisplay();
                }
            }
        }

        // Start the game
        const game = new Game();
        window.game = game;
    </script>
</body>
</html>
