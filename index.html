<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Adventure Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #e0e0e0;
            overflow-x: hidden;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile browsers */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            margin: 0;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height */
            width: 100%;
            max-width: 600px;
            max-height: 800px;
            margin: 0 auto;
            position: relative;
            background: #1a1a1a;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            /* Account for iOS safe areas */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }

        #imageContainer {
            width: 100%;
            height: 25vh;
            background: #000;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: height 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
        }

        #imageContainer.expanded {
            height: 50vh;
        }

        #imageContainer.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 200;
            background: #000;
        }

        #roomImage {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            touch-action: none;
        }

        #textArea {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: #0a0a0a;
            border-top: 2px solid #333;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            transition: all 0.3s ease;
        }

        #imageContainer.expanded + #textArea {
            max-height: 30vh;
        }

        #chipsContainer {
            padding: 10px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            background: #1a1a1a;
            border-top: 2px solid #333;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 30vh;
            overflow-y: auto;
            position: relative;
            /* Ensure chips are above iOS bottom bar */
            margin-bottom: env(safe-area-inset-bottom);
        }

        .chip {
            padding: 10px 16px;
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 20px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .chip:hover, .chip:active {
            background: #3a3a3a;
            border-color: #666;
            transform: scale(0.98);
        }

        .chip.hard-to-find {
            opacity: 0.5;
            border-style: dashed;
        }

        .chip.inventory-btn {
            background: #1a4a5a;
            border-color: #4a9eff;
            font-weight: bold;
        }

        .chip.inventory-btn:hover {
            background: #2a5a6a;
        }

        #inventoryPanel {
            position: fixed;
            bottom: 20vh;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            max-height: 300px;
            background: rgba(30, 30, 30, 0.98);
            border: 2px solid #666;
            border-radius: 10px;
            padding: 15px;
            z-index: 99;
            overflow-y: auto;
            display: none;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
        }

        #inventoryPanel.open {
            display: block;
        }

        #logOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 99;
            display: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        #logOverlay.open {
            display: block;
        }

        #logPanel {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            height: 80vh;
            background: rgba(20, 20, 20, 0.98);
            border: 2px solid #666;
            border-radius: 10px;
            padding: 15px;
            z-index: 100;
            display: none;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.7);
            /* iOS scroll fix */
            -webkit-overflow-scrolling: touch;
            overflow: hidden;
        }

        #logPanel.open {
            display: block;
        }

        /* Prevent body scroll when log is open */
        body.log-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #logContent {
            height: calc(100% - 40px);
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            background: rgba(10, 10, 10, 0.8);
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            /* iOS smooth scrolling */
            -webkit-overflow-scrolling: touch;
            /* Ensure touch events work */
            touch-action: pan-y;
            /* Create scrolling context */
            position: relative;
            z-index: 1;
        }
        #logClose {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 15px;
            background: #666;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        #logClose:hover {
            background: #888;
        }

        #logContent::-webkit-scrollbar {
            width: 8px;
        }

        #logContent::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        #logContent::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 4px;
        }

        #logContent::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        #inventoryPanel::-webkit-scrollbar {
            width: 8px;
        }

        #inventoryPanel::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        #inventoryPanel::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 4px;
        }

        #inventoryPanel::-webkit-scrollbar-thumb:hover {
            background: #888;
        }

        .inventory-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 5px;
            font-size: 12px;
        }

        .room-title {
            font-weight: bold;
            font-size: 18px;
            color: #4a9eff;
            margin-bottom: 10px;
            display: inline-block;
        }

        .room-title::first-line {
            text-decoration: underline;
            text-decoration-thickness: 2px;
            text-underline-offset: 3px;
        }

        .npc-count {
            color: #ffaa00;
            margin: 10px 0;
            display: inline-block;
        }

        .npc-count::after {
            content: '';
            display: block;
            width: 100%;
            height: 2px;
            background: #ffaa00;
            margin-top: 2px;
        }

        .destination-count {
            color: #00ff88;
            margin: 10px 0;
            display: inline-block;
        }

        .destination-count::after {
            content: '';
            display: block;
            width: 100%;
            height: 2px;
            background: #00ff88;
            margin-top: 2px;
        }

        .conditional-text {
            color: #ff9eff;
            font-style: italic;
            margin: 10px 0;
            padding: 10px;
            border-left: 3px solid #ff9eff;
        }

        .item-notice {
            color: #88ddff;
            font-style: italic;
            margin: 5px 0;
        }

        #winMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            color: #0f0;
            padding: 40px;
            border: 3px solid #0f0;
            font-family: monospace;
            font-size: 14px;
            text-align: center;
            display: none;
            z-index: 200;
            white-space: pre;
        }

        /* Standalone app mode (when added to home screen) */
        @media (display-mode: standalone) {
            body {
                padding-top: 20px; /* Status bar height */
            }
            
            #gameContainer {
                padding-top: 20px;
            }
        }
        
        /* Fix for iOS minimal-ui mode */
        @supports (-webkit-touch-callout: none) {
            #gameContainer {
                min-height: -webkit-fill-available;
            }
        }
        @media (max-width: 768px) {
            body {
                padding: 0;
                background: #1a1a1a;
            }
            
            #gameContainer {
                max-width: 100%;
                max-height: 100%;
                height: 100vh;
                height: 100dvh;
                box-shadow: none;
                border-radius: 0;
            }
            
            /* Extra padding for iOS devices */
            @supports (padding: env(safe-area-inset-top)) {
                #gameContainer {
                    padding-top: env(safe-area-inset-top);
                    padding-bottom: 0; /* Handled by chips container */
                }
                
                #imageContainer {
                    margin-top: 0;
                }
                
                #chipsContainer {
                    padding-bottom: max(10px, env(safe-area-inset-bottom));
                    margin-bottom: 0;
                }
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="imageContainer">
            <img id="roomImage" alt="Room">
        </div>
        <div id="textArea"></div>
        <div id="chipsContainer"></div>
        <div id="inventoryPanel"></div>
    </div>
    <div id="winMessage"></div>
    <div id="logPanel">
        <button id="logClose" onclick="game.closeLog()">Ã—</button>
        <h3 style="color: #4a9eff; margin-bottom: 10px;">ðŸ“œ Session Log</h3>
        <div id="logContent"></div>
    </div>
    <audio id="bgMusic" loop></audio>

    <script>
        class Game {
            constructor() {
                this.world = null;
                this.currentRoom = 0;
                this.inventory = [];
                this.textQueue = [];
                this.isTyping = false;
                this.currentAudio = null;
                this.fadeInterval = null;
                this.musicStarted = false;
                this.pendingMusic = null;
                this.sessionLog = []; // Track all text shown to user
                this.init();
            }

            async init() {
                // Add click listener for first interaction to start music
                document.addEventListener('click', () => {
                    if (!this.musicStarted && this.pendingMusic) {
                        this.musicStarted = true;
                        this.startNewMusic(this.pendingMusic);
                    }
                }, { once: true });

                // Load world data - try the provided filename first
                try {
                    const response = await fetch('world_hando_expanded.json');
                    this.world = await response.json();
                    this.currentRoom = this.world.meta.spawn_points[Math.floor(Math.random() * this.world.meta.spawn_points.length)];
                    this.inventory = [...this.world.meta.starter_inventory];
                    
                    this.setupEventListeners();
                    this.describeRoom();
                } catch (error) {
                    // If that fails, try the original filename
                    try {
                        const response = await fetch('world_small.json');
                        this.world = await response.json();
                        this.currentRoom = this.world.meta.spawn_points[Math.floor(Math.random() * this.world.meta.spawn_points.length)];
                        this.inventory = [...this.world.meta.starter_inventory];
                        
                        this.setupEventListeners();
                        this.describeRoom();
                    } catch (error2) {
                        this.addText("Error loading world data. Please ensure world_hando_expanded.json or world_small.json is available.");
                        console.error(error2);
                    }
                }
            }

            setupEventListeners() {
                // Image interaction handlers
                const imageContainer = document.getElementById('imageContainer');
                const roomImage = document.getElementById('roomImage');
                let pressTimer = null;
                let isLongPress = false;
                let lastTap = 0;
                let initialPinchDistance = null;
                let isPinching = false;
                
                // Helper function to get distance between two touch points
                const getTouchDistance = (e) => {
                    if (e.touches.length < 2) return null;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                };
                
                // Handle pinch gestures for mobile
                imageContainer?.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        isPinching = true;
                        initialPinchDistance = getTouchDistance(e);
                    } else if (e.touches.length === 1) {
                        // Start press timer for long press
                        startPress(e);
                    }
                }, { passive: false });
                
                imageContainer?.addEventListener('touchmove', (e) => {
                    if (isPinching && e.touches.length === 2) {
                        e.preventDefault();
                        const currentDistance = getTouchDistance(e);
                        if (initialPinchDistance && currentDistance) {
                            const distanceChange = currentDistance - initialPinchDistance;
                            // If pinch out (expand) by more than 30 pixels
                            if (distanceChange > 30) {
                                imageContainer.classList.add('expanded');
                                isPinching = false;
                                initialPinchDistance = null;
                            }
                            // If pinch in (contract) by more than 30 pixels
                            else if (distanceChange < -30) {
                                imageContainer.classList.remove('expanded');
                                isPinching = false;
                                initialPinchDistance = null;
                            }
                        }
                    }
                }, { passive: false });
                
                imageContainer?.addEventListener('touchend', (e) => {
                    if (isPinching) {
                        isPinching = false;
                        initialPinchDistance = null;
                    }
                    endPress(e);
                }, { passive: false });
                
                // Double tap to toggle size (backup for iOS)
                imageContainer?.addEventListener('click', (e) => {
                    e.preventDefault();
                    const currentTime = new Date().getTime();
                    const tapLength = currentTime - lastTap;
                    
                    if (tapLength < 500 && tapLength > 0) {
                        // Double tap detected
                        imageContainer.classList.toggle('expanded');
                        // Adjust text area scroll after size change
                        setTimeout(() => {
                            const textArea = document.getElementById('textArea');
                            if (textArea) textArea.scrollTop = textArea.scrollHeight;
                        }, 350);
                    }
                    lastTap = currentTime;
                });
                
                // Press and hold for fullscreen
                const startPress = (e) => {
                    if (isPinching) return; // Don't start long press if pinching
                    e.preventDefault();
                    isLongPress = false;
                    pressTimer = setTimeout(() => {
                        isLongPress = true;
                        imageContainer?.classList.add('fullscreen');
                    }, 500); // 500ms hold for fullscreen
                };
                
                const endPress = (e) => {
                    e.preventDefault();
                    if (pressTimer) clearTimeout(pressTimer);
                    if (isLongPress) {
                        imageContainer?.classList.remove('fullscreen');
                        isLongPress = false;
                    }
                };
                
                // Mouse events for desktop (keep existing functionality)
                imageContainer?.addEventListener('mousedown', startPress);
                imageContainer?.addEventListener('mouseup', endPress);
                imageContainer?.addEventListener('mouseleave', endPress);
                
                // Prevent context menu on long press
                imageContainer?.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            d20() {
                return Math.floor(Math.random() * 20) + 1;
            }

            difficultyCheck(diff, advantage, disadvantage) {
                const firstRoll = this.d20();
                const secondRoll = this.d20();
                const goal = diff + 10;

                if (advantage === disadvantage) {
                    return firstRoll >= goal;
                }
                if (advantage) {
                    return Math.max(firstRoll, secondRoll) >= goal;
                }
                if (disadvantage) {
                    return Math.min(firstRoll, secondRoll) >= goal;
                }
                return false;
            }

            getRoomById(roomId) {
                if (!this.world) return null;
                return this.world.world.find(r => r.id === roomId) || null;
            }

            hasRequires(requires) {
                for (const req of requires) {
                    const found = this.inventory.some(item => 
                        item.name === req || item.type === req
                    );
                    if (!found) return false;
                }
                return true;
            }

            findTypes() {
                return new Set(this.inventory.map(item => item.type));
            }

            async playMusic(filename) {
                // Store the music to play if we haven't started yet
                if (!this.musicStarted) {
                    this.pendingMusic = filename;
                    return;
                }
                
                const audio = document.getElementById('bgMusic');
                
                // Clear any existing fade intervals
                if (this.fadeInterval) {
                    clearInterval(this.fadeInterval);
                    this.fadeInterval = null;
                }
                
                // Fade out current music if playing
                if (audio && audio.volume > 0 && !audio.paused) {
                    let fadeVolume = audio.volume;
                    const fadeOut = setInterval(() => {
                        fadeVolume -= 0.1;
                        if (fadeVolume <= 0) {
                            audio.volume = 0;
                            audio.pause();
                            clearInterval(fadeOut);
                            // Now start new music
                            this.startNewMusic(filename);
                        } else {
                            audio.volume = fadeVolume;
                        }
                    }, 50);
                } else {
                    // No music playing, start immediately
                    this.startNewMusic(filename);
                }
            }

            startNewMusic(filename) {
                const audio = document.getElementById('bgMusic');
                audio.src = filename;
                audio.volume = 0;
                
                // Try to play, and if successful, fade in
                audio.play().then(() => {
                    let fadeVolume = 0;
                    this.fadeInterval = setInterval(() => {
                        fadeVolume += 0.1;
                        if (fadeVolume >= 1) {
                            audio.volume = 1;
                            clearInterval(this.fadeInterval);
                            this.fadeInterval = null;
                        } else {
                            audio.volume = fadeVolume;
                        }
                    }, 50);
                }).catch(() => {
                    // Audio couldn't play (likely autoplay policy)
                });
                
                this.currentAudio = audio;
            }

            async loadImage(filename) {
                const img = document.getElementById('roomImage');
                img.src = filename;
                img.onerror = () => {
                    img.src = ''; // Clear if image not found
                };
            }

            getConditionalDescriptions(room) {
                if (!room.conditional_descriptions) return [];
                
                const activeDescriptions = [];
                for (const condDesc of room.conditional_descriptions) {
                    if (this.hasRequires(condDesc.requirements)) {
                        activeDescriptions.push(condDesc.text);
                    }
                }
                return activeDescriptions;
            }

            describeRoom() {
                const room = this.getRoomById(this.currentRoom);
                if (!room) return;

                // Clear text area for new room
                const textArea = document.getElementById('textArea');
                textArea.innerHTML = '';

                // Load image and music
                const imageName = `images/${this.currentRoom}a.png`;
                const musicName = `audio/${this.currentRoom}a.m4a`;
                
                this.loadImage(imageName);
                this.playMusic(musicName);

                // Build description - add click instruction if music hasn't started
                let text = '';
                if (!this.musicStarted) {
                    text += '[Click anywhere to start audio]\n\n';
                }
                
                // Format room title with full first word underlined
                const roomName = room.name;
                const firstSpaceIndex = roomName.indexOf(' ');
                const firstWord = firstSpaceIndex > -1 ? roomName.substring(0, firstSpaceIndex) : roomName;
                const restOfName = firstSpaceIndex > -1 ? roomName.substring(firstSpaceIndex) : '';
                
                text += `<span class="room-title"><span style="text-decoration: underline; text-decoration-thickness: 2px; text-underline-offset: 3px;">${firstWord}</span>${restOfName}</span>\n`;
                text += '-----------------\n';
                text += `${room.description}\n\n`;

                // Add conditional descriptions
                const conditionalTexts = this.getConditionalDescriptions(room);
                for (const condText of conditionalTexts) {
                    text += `<span class="conditional-text">${condText}</span>\n\n`;
                }

                // NPCs with styled count
                if (room.npcs && room.npcs.length > 0) {
                    const npcText = `There ${room.npcs.length === 1 ? 'is 1 person' : `are ${room.npcs.length} people`} in the room:`;
                    const npcFirstSpace = npcText.indexOf(' ');
                    const npcFirstWord = npcFirstSpace > -1 ? npcText.substring(0, npcFirstSpace) : npcText;
                    const npcRest = npcFirstSpace > -1 ? npcText.substring(npcFirstSpace) : '';
                    
                    text += `<span class="npc-count"><span style="border-bottom: 2px solid #ffaa00; padding-bottom: 2px;">${npcFirstWord}</span>${npcRest}</span>\n`;
                    for (const npc of room.npcs) {
                        text += ` â€¢ ${npc.name} - ${npc.short_desc || npc.description || 'Person'}\n`;
                    }
                    text += '\n';
                }

                // Exits with styled count
                const exitCount = Object.keys(room.exits).length;
                const exitText = `There ${exitCount === 1 ? 'is 1 destination' : `are ${exitCount} destinations`}:`;
                const exitFirstSpace = exitText.indexOf(' ');
                const exitFirstWord = exitFirstSpace > -1 ? exitText.substring(0, exitFirstSpace) : exitText;
                const exitRest = exitFirstSpace > -1 ? exitText.substring(exitFirstSpace) : '';
                
                text += `<span class="destination-count"><span style="border-bottom: 2px solid #00ff88; padding-bottom: 2px;">${exitFirstWord}</span>${exitRest}</span>\n`;
                for (const [direction, exits] of Object.entries(room.exits)) {
                    text += ` â€¢ ${direction}`;
                    for (const exit of exits) {
                        text += ` - ${exit.short_desc}`;
                    }
                    text += '\n';
                }

                this.addText(text);
                this.updateChips();
            }

            addText(text) {
                this.textQueue.push(text);
                // Add to session log (strip HTML tags for cleaner log)
                const cleanText = text.replace(/<[^>]*>/g, '');
                this.sessionLog.push(cleanText);
                if (!this.isTyping) {
                    this.typeText();
                }
            }

            async typeText() {
                if (this.textQueue.length === 0) {
                    this.isTyping = false;
                    return;
                }

                this.isTyping = true;
                const text = this.textQueue.shift();
                const textArea = document.getElementById('textArea');
                
                // For instant display (like after GO command), show immediately
                if (text.includes('\n\n\n\n\n')) {
                    textArea.innerHTML = text;
                    textArea.scrollTop = textArea.scrollHeight;
                    this.isTyping = false;
                    this.typeText();
                    return;
                }

                // Type out character by character
                let index = 0;
                const typingSpeed = 10; // Delay between character chunks
                const charsPerChunk = 4; // Drop 4 characters at once for faster reading
                
                const typeChar = () => {
                    if (index < text.length) {
                        let chunkSize = 0;
                        let chunkText = '';
                        
                        // Process up to charsPerChunk characters
                        while (chunkSize < charsPerChunk && index < text.length) {
                            // Handle HTML tags
                            if (text[index] === '<') {
                                const closeTag = text.indexOf('>', index);
                                if (closeTag !== -1) {
                                    chunkText += text.substring(index, closeTag + 1);
                                    index = closeTag + 1;
                                    // Don't count HTML tags in chunk size
                                } else {
                                    chunkText += text[index];
                                    index++;
                                    chunkSize++;
                                }
                            } else {
                                chunkText += text[index];
                                index++;
                                chunkSize++;
                            }
                        }
                        
                        textArea.innerHTML += chunkText;
                        
                        // Always scroll to bottom to keep new text visible
                        textArea.scrollTop = textArea.scrollHeight;
                        
                        setTimeout(typeChar, typingSpeed);
                    } else {
                        // Final scroll to ensure everything is visible
                        textArea.scrollTop = textArea.scrollHeight;
                        this.isTyping = false;
                        this.typeText();
                    }
                };
                
                typeChar();
            }

            go(direction) {
                const room = this.getRoomById(this.currentRoom);
                if (!room) return;

                if (!(direction in room.exits)) {
                    this.addText("You can't go that way\n");
                    return;
                }

                const exits = room.exits[direction];
                for (let i = exits.length - 1; i >= 0; i--) {
                    const exit = exits[i];
                    if (this.hasRequires(exit.requires)) {
                        this.currentRoom = exit.to;
                        // Add clear separation between traversal and room description
                        this.addText('\n\n\n\n\n' + exit.traversal + '\n\n');
                        // Small delay before room description for readability
                        setTimeout(() => this.describeRoom(), 100);
                        return;
                    }
                }

                // If we get here, we're blocked
                this.addText(exits[exits.length - 1].blocked_text + '\n');
            }

            getItem(itemName) {
                const room = this.getRoomById(this.currentRoom);
                if (!room) return;

                const itemIndex = room.items.findIndex(item => 
                    item.name.toUpperCase() === itemName.toUpperCase()
                );

                if (itemIndex !== -1) {
                    const item = room.items[itemIndex];
                    this.inventory.push(item);
                    room.items.splice(itemIndex, 1);
                    
                    // Print both the standard message and the item's notice
                    let message = `You take the ${item.name}\n`;
                    if (item.notice) {
                        message += `<span class="item-notice">${item.notice}</span>\n`;
                    }
                    this.addText(message);
                    
                    // Check if this unlocked any conditional text
                    const conditionalTexts = this.getConditionalDescriptions(room);
                    for (const condText of conditionalTexts) {
                        // Check if this is a newly revealed text
                        if (!this.revealedTexts) this.revealedTexts = new Set();
                        const textKey = `${this.currentRoom}_${condText}`;
                        if (!this.revealedTexts.has(textKey)) {
                            this.revealedTexts.add(textKey);
                            this.addText(`\n<span class="conditional-text">New insight: ${condText}</span>\n`);
                        }
                    }
                    
                    this.updateChips();
                } else {
                    this.addText(`You search and you cannot find the ${itemName}\n`);
                }
            }

            showLog() {
                const logPanel = document.getElementById('logPanel');
                const logContent = document.getElementById('logContent');
                
                if (logPanel && logContent) {
                    // Join all session log entries with some separation
                    logContent.innerHTML = this.sessionLog.join('\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n');
                    logPanel.classList.add('open');
                    // Scroll to bottom to show most recent
                    logContent.scrollTop = logContent.scrollHeight;
                }
            }

            closeLog() {
                const logPanel = document.getElementById('logPanel');
                if (logPanel) {
                    logPanel.classList.remove('open');
                }
            }

            look() {
                // Deprecated - keeping for compatibility but now shows log
                this.showLog();
            }

            talk(npcName) {
                const room = this.getRoomById(this.currentRoom);
                if (!room || !room.npcs) return;

                const npc = room.npcs.find(n => n.name.toUpperCase() === npcName.toUpperCase());
                if (npc) {
                    const dialogue = Array.isArray(npc.dialogue) 
                        ? npc.dialogue[Math.floor(Math.random() * npc.dialogue.length)]
                        : npc.dialogue;
                    this.addText(`${npc.name} says: ${dialogue}\n`);
                }
            }

            craftInputs(itemName) {
                if (!this.world || !this.world.meta.crafting) return [];
                const recipe = this.world.meta.crafting.interactions.find(r => 
                    r.output.toUpperCase() === itemName.toUpperCase()
                );
                return recipe ? recipe.input : [];
            }

            craftable(itemName) {
                const inputs = this.craftInputs(itemName);
                if (inputs.length === 0) return false;
                
                return inputs.every(input => 
                    this.inventory.some(item => item.name === input)
                );
            }

            craft(itemName) {
                if (!this.world || !this.world.meta.crafting) return;
                
                if (this.craftable(itemName)) {
                    // Remove ingredients
                    const inputs = this.craftInputs(itemName);
                    for (const input of inputs) {
                        const index = this.inventory.findIndex(item => item.name === input);
                        if (index !== -1) {
                            this.inventory.splice(index, 1);
                        }
                    }

                    // Add crafted item
                    const recipe = this.world.meta.crafting.interactions.find(r => 
                        r.output.toUpperCase() === itemName.toUpperCase()
                    );
                    if (recipe) {
                        const craftedItem = {
                            name: recipe.output,
                            type: recipe.type,
                            notice: recipe.notice,
                            notes: recipe.notes
                        };
                        this.inventory.push(craftedItem);
                        
                        // Show crafting message and the item's notice
                        let message = `You craft the ${itemName}\n`;
                        if (craftedItem.notice) {
                            message += `<span class="item-notice">${craftedItem.notice}</span>\n`;
                        }
                        this.addText(message);
                        
                        // Check if this crafting unlocked any conditional text
                        const room = this.getRoomById(this.currentRoom);
                        const conditionalTexts = this.getConditionalDescriptions(room);
                        for (const condText of conditionalTexts) {
                            if (!this.revealedTexts) this.revealedTexts = new Set();
                            const textKey = `${this.currentRoom}_${condText}`;
                            if (!this.revealedTexts.has(textKey)) {
                                this.revealedTexts.add(textKey);
                                this.addText(`\n<span class="conditional-text">...: ${condText}</span>\n`);
                            }
                        }
                    }
                } else {
                    this.addText("You can't quite piece it together\n");
                    
                    // Show what can be crafted
                    if (this.world) {
                        let foundAny = false;
                        let craftableItems = "You could craft:\n";
                        for (const recipe of this.world.meta.crafting.interactions) {
                            if (this.craftable(recipe.output)) {
                                if (!foundAny) {
                                    this.addText(craftableItems);
                                    foundAny = true;
                                }
                                this.addText(recipe.output + '\n');
                            }
                        }
                    }
                }
                
                this.updateChips();
                this.updateInventoryDisplay();
            }

            give(itemName, personName) {
                const room = this.getRoomById(this.currentRoom);
                if (!room || !room.trades) return;

                // Find matching trade
                for (const trade of room.trades) {
                    if (trade.name.toUpperCase() === personName.toUpperCase()) {
                        // Check if we have all required items
                        if (trade.input.includes(itemName) && 
                            trade.input.every(input => this.inventory.some(item => item.name === input))) {
                            
                            // Remove traded items
                            for (const input of trade.input) {
                                const index = this.inventory.findIndex(item => item.name === input);
                                if (index !== -1) {
                                    this.inventory.splice(index, 1);
                                }
                            }

                            // Add received items with their notices
                            for (const output of trade.output) {
                                let message = '';
                                if (output.notice) {
                                    message = `<span class="item-notice">${output.notice}</span>\n`;
                                }
                                this.addText(message);
                                this.inventory.push(output);
                            }
                            
                            this.updateChips();
                            this.updateInventoryDisplay();
                            return;
                        } else {
                            this.addText(trade.failure + '\n');
                            return;
                        }
                    }
                }
            }

            save() {
                if (!this.world) return;
                
                const saveData = {
                    ...this.world,
                    meta: {
                        ...this.world.meta,
                        spawn_points: [this.currentRoom],
                        starter_inventory: this.inventory
                    }
                };
                
                const blob = new Blob([JSON.stringify(saveData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'save.json';
                a.click();
                URL.revokeObjectURL(url);
                
                this.addText("Game saved!\n");
            }

            async loadSave() {
                // Create invisible file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                
                fileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        try {
                            const text = await file.text();
                            const saveData = JSON.parse(text);
                            
                            // Load the saved game state
                            this.world = saveData;
                            this.currentRoom = saveData.meta.spawn_points[0];
                            this.inventory = [...saveData.meta.starter_inventory];
                            
                            // Clear and redraw everything
                            const textArea = document.getElementById('textArea');
                            textArea.innerHTML = '';
                            
                            this.addText("Save file loaded successfully!\n\n");
                            this.describeRoom();
                        } catch (error) {
                            this.addText("Error loading save file. Please check the file and try again.\n");
                            console.error(error);
                        }
                    } else {
                        // No file selected, do a normal restart
                        if (confirm('No save file selected. Start a new game?')) {
                            location.reload();
                        }
                    }
                };
                
                // Trigger file selection dialog
                fileInput.click();
            }

            restart() {
                location.reload();
            }

            checkWin() {
                if (!this.world || !this.world.meta.parallel_portal) return false;
                const room = this.getRoomById(this.currentRoom);
                return room?.name === this.world.meta.parallel_portal.portal_room;
            }

            showWinMessage() {
                const winMessage = document.getElementById('winMessage');
                winMessage.innerHTML = `
  ____                            _         _       _   _                   
 / ___|___  _ __   __ _ _ __ __ _| |_ _   _| | __ _| |_(_) ___  _ __  ___   
| |   / _ \\| '_ \\ / _\` | '__/ _\` | __| | | | |/ _\` | __| |/ _ \\| '_ \\/ __|  
| |__| (_) | | | | (_| | | | (_| | |_| |_| | | (_| | |_| | (_) | | | \\__ \\_ 
 \\____\\___/|_| |_|\\__, |_|  \\__,_|\\__|\\__,_|_|\\__,_|\\__|_|\\___/|_| |_|___( )
                  |___/                                                  |/ 
__   __           __        ___         _   _   _ 
\\ \\ / /__  _   _  \\ \\      / (_)_ __   | | | | | |
 \\ V / _ \\| | | |  \\ \\ /\\ / /| | '_ \\  | | | | | |
  | | (_) | |_| |   \\ V  V / | | | | | |_| |_| |_|
  |_|\\___/ \\__,_|    \\_/\\_/  |_|_| |_| (_) (_) (_)`;
                winMessage.style.display = 'block';
            }

            updateInventoryDisplay() {
                const panel = document.getElementById('inventoryPanel');
                if (!panel || !panel.classList.contains('open')) return;

                let html = '<h3 style="color: #4a9eff; margin-bottom: 10px;">ðŸ“¦ Inventory</h3>';
                
                const sortedInventory = [...this.inventory].sort((a, b) => 
                    a.name.localeCompare(b.name)
                );
                
                for (const item of sortedInventory) {
                    const notes = item.notes || 'Normal item';
                    html += `<div class="inventory-item">${item.name} - ${notes}</div>`;
                }
                
                if (sortedInventory.length === 0) {
                    html += '<div class="inventory-item">Empty</div>';
                }
                
                panel.innerHTML = html;
            }

            toggleInventory() {
                const invPanel = document.getElementById('inventoryPanel');
                if (invPanel) {
                    invPanel.classList.toggle('open');
                    this.updateInventoryDisplay();
                }
            }

            updateChips() {
                const container = document.getElementById('chipsContainer');
                
                // Save inventory panel state before updating
                const invPanel = document.getElementById('inventoryPanel');
                const wasOpen = invPanel?.classList.contains('open');
                
                const chips = [];
                
                // Always show inventory button first
                chips.push(`<div class="chip inventory-btn" onclick="game.toggleInventory()">ðŸ“¦ Inventory</div>`);
                
                const room = this.getRoomById(this.currentRoom);
                if (!room) return;

                // Check for win condition
                if (this.checkWin()) {
                    this.showWinMessage();
                    container.innerHTML = chips.join('');
                    // Restore inventory state
                    if (wasOpen && invPanel) {
                        invPanel.classList.add('open');
                    }
                    return;
                }

                // Navigation chips
                for (const direction of Object.keys(room.exits)) {
                    chips.push(`<div class="chip" onclick="game.go('${direction}')">Go ${direction}</div>`);
                }

                // Item chips (both visible and hard to find)
                if (room.items) {
                    for (const item of room.items) {
                        const myTypes = this.findTypes();
                        let difficulty = 'normal';
                        
                        if (!item.found && item.find_difficulty && item.find_difficulty > 0) {
                            let adv = false;
                            let dis = false;
                            
                            if (item.check) {
                                const advTypes = new Set(item.check.advantage_if_types || []);
                                const disTypes = new Set(item.check.disadvantage_if_missing_types || []);
                                
                                if (advTypes.size > 0) {
                                    adv = [...advTypes].every(t => myTypes.has(t));
                                }
                                
                                if (disTypes.size > 0 && ![...disTypes].some(t => myTypes.has(t))) {
                                    dis = true;
                                }
                            }
                            
                            // Make it translucent if hard to find
                            if (item.find_difficulty > 0 || dis) {
                                difficulty = 'hard-to-find';
                            }
                        }
                        
                        const itemNameEscaped = item.name.replace(/'/g, "\\'");
                        chips.push(`<div class="chip ${difficulty === 'hard-to-find' ? 'hard-to-find' : ''}" onclick="game.getItem('${itemNameEscaped}')">Get ${item.name}</div>`);
                    }
                }

                // Look chip
                chips.push(`<div class="chip" onclick="game.showLog()">Log</div>`);

                // Talk chips
                if (room.npcs) {
                    for (const npc of room.npcs) {
                        const npcNameEscaped = npc.name.replace(/'/g, "\\'");
                        chips.push(`<div class="chip" onclick="game.talk('${npcNameEscaped}')">Talk ${npc.name}</div>`);
                    }
                }

                // Give chips (for trades)
                if (room.trades) {
                    const tradeableItems = new Set();
                    for (const trade of room.trades) {
                        for (const input of trade.input) {
                            if (this.inventory.some(item => item.name === input)) {
                                tradeableItems.add(`${input} to ${trade.name}`);
                            }
                        }
                    }
                    
                    for (const trade of tradeableItems) {
                        const [item, person] = trade.split(' to ');
                        const itemEscaped = item.replace(/'/g, "\\'");
                        const personEscaped = person.replace(/'/g, "\\'");
                        chips.push(`<div class="chip" onclick="game.give('${itemEscaped}', '${personEscaped}')">Give ${trade}</div>`);
                    }
                }

                // Craft chips
                if (this.world && this.world.meta.crafting) {
                    for (const recipe of this.world.meta.crafting.interactions) {
                        if (this.craftable(recipe.output)) {
                            const outputEscaped = recipe.output.replace(/'/g, "\\'");
                            chips.push(`<div class="chip" onclick="game.craft('${outputEscaped}')">Craft ${recipe.output}</div>`);
                        }
                    }
                }

                // System chips
                chips.push(`<div class="chip" onclick="game.save()">Save</div>`);
                chips.push(`<div class="chip" onclick="game.loadSave()">Load</div>`);

                container.innerHTML = chips.join('');
                
                // Restore inventory panel state if it was open
                if (wasOpen && invPanel) {
                    invPanel.classList.add('open');
                    this.updateInventoryDisplay();
                }
            }
        }

        // Start the game
        const game = new Game();
        window.game = game;
    </script>
</body>
</html>
